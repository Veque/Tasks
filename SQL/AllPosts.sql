/*
Я использую таблицу TagPost как связующую между статьями и тегами. 
Отдельной таблицы для тегов я не делаю, потому что чаще всего теги отдельно не заводяться.
Они цепляются в полусвободном режиме к статьям. Так же я полагаю, что теги отдельно от статей не существуют. Данная таблица позволяет быстро искать статьи по тегам, без лишнего Index Peek'а.
При поиске всех пар статья-тег (в файле AllPosts.sql) SQL сервер должен (полагаю, что статей и тегов очень много) отсортировать таблицу TagPost по PostId и, выполнив джоин с сортировкой, вернуть результат.
Если была третья таблица, то для каждой строки был бы поиск по ключу. 

Оверхед сортировки не большой (во многом благодаря тому, что размер строки ме=аленький, но его можно уменьшить, сделав Name фиксированного размера). 
Если это не так, то можно добавить еще одну таблицу dbo.PostTag с обратным ключом (PostId,Name). 
Тогда выборка всех пар статья-тег будет быстрее, но будет риск рассинхронизации двух таблиц.
Если сделать одну таблицу с двумя индексами, то сложнее бороться с дедлоками.

Отдельную таблицу для тегов следует делать, если ими требуется управлять отдельно, если они могут существовать не прикрепленными к таблицам.

P.S. SQL Server'а у меня под рукой нет, проверить не могу, да и времени мало осталось. Прошу прощения, если скрипт работает не так, как я планировал.
*/
SELECT 
p.[Name] AS [Post],
t.[Name] AS [Tag]
FROM dbo.Post p
LEFT JOIN dbo.TagPost t 
--WITH (READPAST) -- Пропуск заблокированных записей. Можно применить, если не страшен пропуск каких-то записей, которые в процессе добавления/удаления
--WITH (NOLOCK) -- не блокировать запись в таблицу. Можно применить, если не страшно, что результат будет не всегда корректен.
	ON t.PostId = p.Id